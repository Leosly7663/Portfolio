// app/api/managedRules/[id]/route.ts
import { NextResponse } from "next/server";
import { createClient } from "@supabase/supabase-js";

export const runtime = "nodejs";
export const dynamic = "force-dynamic";
export const revalidate = 0;

type RebalanceCadence = "off" | "daily" | "weekly" | "monthly" | "quarterly";
type RuleMode = "threshold" | "schedule" | "off";

export type ManagedRuleRow = {
  id: number;                         // PK in "Soln0002 - Rules"
  name?: string | null;
  active: boolean;
  target_pct: number | null;
  rebalance: { mode: RuleMode; thresholdPct: number | null; cadence: RebalanceCadence };
  risk: { stopLossPct: number | null; takeProfitPct: number | null; trailing: boolean };
  dca: { enabled: boolean; every: "week" | "month"; quantity: number | null; dayOfWeek: number | null; dayOfMonth: number | null };
  notes: string | null;
  updated_at?: string | null;
};

const supabase = createClient(
  process.env.NEXT_PUBLIC_SUPABASE_URL!,
  process.env.SUPABASE_SERVICE_ROLE_KEY!,
  { auth: { persistSession: false } }
);

// helpers
const bad = (msg: string, status = 400) => NextResponse.json({ error: msg }, { status });
const notFound = () => NextResponse.json({ error: "Not found" }, { status: 404 });
const ok = <T,>(data: T, status = 200) => NextResponse.json(data, { status });
const parseId = (p: { id?: string }) => {
  const n = Number.parseInt(String(p.id ?? ""), 10);
  return Number.isFinite(n) ? n : null;
};
async function readBody<T>(req: Request): Promise<T | null> {
  try { return (await req.json()) as T; } catch { return null; }
}

// GET /api/managedRules/[id]  -> by ruleId
export async function GET(_req: Request, { params }: { params: { id?: string } }) {
  const id = parseId(params);
  if (id == null) return bad("Invalid id");

  const { data, error } = await supabase
    .from("Soln0002 - Rules")
    .select("*")
    .eq("id", id)
    .maybeSingle();

  if (error) return bad(error.message, 500);
  if (!data) return notFound();
  return ok<ManagedRuleRow>(data as ManagedRuleRow);
}

// PUT /api/managedRules/[id]  -> upsert by ruleId
export async function PUT(req: Request, { params }: { params: { id?: string } }) {
  const id = parseId(params);
  if (id == null) return bad("Invalid id");

  const body = (await readBody<Partial<ManagedRuleRow>>(req)) || {};

  // sanitize/shape defaults
  const payload: ManagedRuleRow = {
    id,
    name: body.name ?? null,
    active: body.active ?? true,
    target_pct: body.target_pct ?? null,
    rebalance: {
      mode: (body.rebalance?.mode as RuleMode) ?? "off",
      thresholdPct: body.rebalance?.thresholdPct ?? null,
      cadence: (body.rebalance?.cadence as RebalanceCadence) ?? "off",
    },
    risk: {
      stopLossPct: body.risk?.stopLossPct ?? null,
      takeProfitPct: body.risk?.takeProfitPct ?? null,
      trailing: body.risk?.trailing ?? false,
    },
    dca: {
      enabled: body.dca?.enabled ?? false,
      every: (body.dca?.every as "week" | "month") ?? "week",
      quantity: body.dca?.quantity ?? null,
      dayOfWeek: body.dca?.dayOfWeek ?? 1,
      dayOfMonth: body.dca?.dayOfMonth ?? 1,
    },
    notes: body.notes ?? null,
    updated_at: undefined, // let DB trigger handle this
  };

  // Note: upsert needs PK insertability. Ensure id is GENERATED BY DEFAULT (not ALWAYS).
  const { data, error } = await supabase
    .from("Soln0002 - Rules")
    .upsert(payload, { onConflict: "id" })
    .select("*")
    .single();

  if (error) return bad(error.message, 500);
  return ok<ManagedRuleRow>(data as ManagedRuleRow);
}

// DELETE /api/managedRules/[id]  -> by ruleId
export async function DELETE(_req: Request, { params }: { params: { id?: string } }) {
  const id = parseId(params);
  if (id == null) return bad("Invalid id");

  const { error } = await supabase
    .from("Soln0002 - Rules")
    .delete()
    .eq("id", id);

  if (error) return bad(error.message, 500);
  return new NextResponse(null, { status: 204 });
}
